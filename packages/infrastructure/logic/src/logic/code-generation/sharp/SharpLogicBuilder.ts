import { IDirectory, IFile } from '@falang/frontend-core';
import { ISchemeDto } from '@falang/editor-scheme';
import { SchemeStore } from '@falang/editor-scheme';
import { LogicBuilder } from "../LogicBuilder";
import { SharpLogicSchemeBuilder } from "./SharpLogicSchemeBuilder";
import { sharpLogicIconsBuilder } from "./sharpLogicIconsBuilder";
import { runInAction } from "mobx";
import { CodeBuilder } from '@falang/editor-scheme';
import { IAvailableFunctionItem } from "../../util/loadAvailableFunctions";
import { ExpressionFunctionsNames, expressionFunctions } from "../../constants";
import { getFullTypeName } from "./getFullTypeName";
import { getInfrastructureTypeByFile } from "../util/getInfrastrucureType";

export class SharpLogicBuilder extends LogicBuilder<any> {
  async build(): Promise<void> {
    const rootDir = await this.project.frontRoot.getProjectStructure();
    await this.buildDirectory(rootDir, true);
    await this.buildGlobal();
  }

  private async buildDirectory(directory: IDirectory, isRoot = false) {
    for(const file of directory.files) {
      await this.buildFile(file);
    }
    for(const dir of directory.directories) {
      await this.buildDirectory(dir);
    }
  }

  private async buildFile(file: IFile) {
    const fs = this.project.frontRoot.fs;
    const relativePath = await fs.relativePath(this.projectPath, file.path);
    const newFilePath = (await fs.resolvePath(this.outpuPath, relativePath)).replace('.falang.json', '.cs');
    const fileDir = await fs.dirname(newFilePath);
    if(!(await fs.fileExists(fileDir))) {
      await fs.createDirectory(fileDir);
    }
    const contents = await this.project.frontRoot.loadFile(file.path);
    const doc: ISchemeDto = JSON.parse(contents);
    const infrastructure = getInfrastructureTypeByFile(file);
    if(!infrastructure) {
      console.error(`Wrong file type: ${file.type} (${file.path})`);
      return;
    }
    const scheme = new SchemeStore(
      this.project.frontRoot,
      infrastructure,
      file.type,
      this.projectPath,
      file.path,
      this.project,
    );
    const icon = scheme.createIconFromDto(doc.root, null);
    runInAction(() => {
      scheme.setRoot(icon);
      scheme.sheduleCallback.flush();
      scheme.name = doc.name
      scheme.description = doc.description;
      scheme.id = doc.id;
    });
    const schemeBuilder = new SharpLogicSchemeBuilder({
      iconBuilders: sharpLogicIconsBuilder,
      indexPath: this.indexPath,
      project: this.project,
      scheme,
    });
    const code = await schemeBuilder.build();
    scheme.dispose();
    await fs.saveFile(newFilePath, code);
  }

  private async buildGlobal() {
    const fs = this.project.frontRoot.fs;
    const pathToFalangFile = await fs.resolvePath(this.outpuPath, 'falang_global.cs');
    const rootPath = await this.getSchemesRootPath();

    const imports: string[] = [];
    const b = new CodeBuilder();
    const availableApis = this.project.availableApis.slice();
    const groupedApis = new Map<string, IGroupedApis>();
    availableApis.forEach((apiData) => {
      const current = groupedApis.get(apiData.schemeId);
      if(!current) {
        groupedApis.set(apiData.schemeId, {
          schemeId: apiData.schemeId,
          schemeName: apiData.schemeName ?? '',
          apis: [apiData],
          name: apiData.name,
        });
      } else {
        current.apis.push(apiData);
      }
    });
    if(groupedApis.size) {
      b.p(`public class Apis {`);
      b.plus();
      for(const value of groupedApis.values()) {
        const apiFilePath = value.apis[0].path;
        const relativePathToApi = await fs.relativePath(rootPath, apiFilePath.replace('.falang.json', ''));
        const pathArray = relativePathToApi.replace('.falang.json', '').split(/[\/\\]/).filter(item => item !== '.');
        if(pathArray.length === 0) return false;
        const importText = pathArray.join('.');
        b.p(`public required Falang.${importText}.${(value.schemeName)} ${value.schemeName};`);
      }
      b.closeQuote();
    }
    b.p('public class FalangGlobal {');
    b.indentPlus();
    if(groupedApis.size) {
      b.p('public required Apis apis;');
    }
    b.closeQuote();

    const fb = new CodeBuilder();
    fb.bigComment([
      'Generated by Falang',
      'Global functions',
    ]);
    fb.p(
      'using System;',
      'using System.IO;',
      'using System.Runtime.Serialization;',
      'using System.Runtime.Serialization.Formatters.Binary;',
      'namespace Falang.Global;',
    );
    fb.appendBuilder(b);
    /**
     * IExpressionFunctions builder
     */
    const eb = new CodeBuilder();
    fb.appendBuilder(eb);
    await fs.saveFile(pathToFalangFile, fb.get());
  }
}

interface IGroupedApis {
  apis: IAvailableFunctionItem[]
  schemeId: string
  schemeName: string
  name: string
}


interface FunciontDataItem {
  name: string
  parameters: string[]
  returnValue: string
}