import * as math from "mathjs";
import { SkewerStore } from '@falang/editor-scheme';
import { CodeBuilder } from '@falang/editor-scheme';
import { TContext, TTypeInfo } from "../../constants";
import { ExpressionStore } from "../../expression/Expression.store";
import { Expression2Store } from "../../expression/Expression2.store";
import { IStructureTypeItem } from "../../ILogicProjectType";
import { IAvailableEnumItem } from "../../util/loadAvailableEnums";
import { IAvailableFunctionItem } from "../../util/loadAvailableFunctions";
import { LogicSchemeBuilder } from "../LogicSchemeBuilder";
import { getParentFunctionIconBlock } from '../util/getParentFunctionIconBlock';
import { hasParentSwitchWithoutCycle } from '../util/hasParentSwitchWithoutCycle';
import { castToNumber } from "./convertSymbol";
import { generateExpression } from "./generateExpression";
import { getFullTypeName } from "./getFullTypeName";

export class SharpLogicSchemeBuilder extends LogicSchemeBuilder {
  private readonly imports = new Set<string>();
  private readonly expressionFunctionsUsed = new Set<string>();
  private logFunctionUsed = false;

  addImport(value: string): void {
    if (this.imports.has(value)) return;
    this.imports.add(value);
  }

  useExpressionFunction(functionName: string): void {
    this.expressionFunctionsUsed.add(functionName);
  }

  useLogFunction(): void {
    this.logFunctionUsed = true;
  }

  async generateExpression(expression: Expression2Store, resultType: TTypeInfo, context?: TContext): Promise<string> {
    const node = expression.mathNode;
    if (!node) throw new Error('Node is null');
    return await this.generateExpressionFromMathNode(node, resultType, context);
  }

  async expr(node: math.MathNode | null, resultType: TTypeInfo, context: TContext): Promise<string> {
    if (!node) {
      throw new Error('Math node is null');
    }
    return this.generateExpressionFromMathNode(node, resultType, context);
  }

  private async generateExpressionFromMathNode(node: math.MathNode, resultType: TTypeInfo, context?: TContext): Promise<string> {
    return await generateExpression({
      node,
      resultType,
      schemeBuilder: this,
      context,
    });
  }

  async build(): Promise<string> {
    if (this.scheme.loaded) {
      await this.generateIcon(this.scheme.root);
    }
    const b = new CodeBuilder();
    b.bigComment([
      'Generated by Falang',
      `Document: ${this.scheme.name}`,
      `Id: ${this.scheme.id}`
    ]);
    /*this.imports.forEach((i) => {
      b.p(i);
    })*/
    const relativePathArray = await this.getSchemeRelativePathArray(this.path);
    b.p(`namespace Falang.${relativePathArray.join('.')};`);
    b.appendBuilder(this.codeBuilder);
    return b.get();
  }

  /**
   * @deprecated
   * @param expression 
   * @param resultType 
   * @returns 
   */
  async generateExpressionOld(expression: ExpressionStore, resultType: TTypeInfo, context?: TContext): Promise<string> {
    const node = expression.mathNode;
    if (!node) throw new Error('Node is null');
    return await this.generateExpressionFromMathNode(node, resultType, context);
  }
  async generateEmptyValue(type: TTypeInfo): Promise<string> {
    switch (type.type) {
      case 'number':
        return castToNumber(type, '0');
      case 'string':
        return 'string.Empty';
      case 'boolean':
        return 'false';
      case 'struct':
        return `new ${await this.getFullTypeName(type)}() {}`;
      case 'array':
        const itemType = await this.getFullTypeName(type.elementType);
        return `new System.Collections.Generic.List<${itemType}>()`;
      default:
        throw new Error(`Wrong type for generateEmptyValue: ${type.type}`);
    }
  }

  async importFunction(item: IAvailableFunctionItem) {
    /*const relativePath = await this.fs.relativePath(await this.getSchemesRootPath(), item.path);
    const pathArray = relativePath.replace('.falang.json', '').split(/[\/\\]/).filter(item => item !== '.');
    const importText = `use crate::falang::${pathArray.join('::')};`;
    this.addImport(importText);*/
  }

  async importStruct(item: IStructureTypeItem) {
    /*const relativePath = await this.fs.relativePath(await this.getSchemesRootPath(), item.path);
    const pathArray = relativePath.replace('.falang.json', '').split(/[\/\\]/).filter(item => item !== '.');
    const importText = `use crate::falang::${pathArray.join('::')};`;
    this.addImport(importText);*/
  }

  async importEnum(item: IAvailableEnumItem) {
    /*const relativePath = await this.fs.relativePath(await this.getSchemesRootPath(), item.path);
    const pathArray = relativePath.replace('.falang.json', '').split(/[\/\\]/).filter(item => item !== '.');
    const importText = `use crate::falang::${pathArray.join('::')};`;
    this.addImport(importText);*/
  }

  async importGlobal() {
    //const importText = `use crate::falang::falang_global;`;
    //this.addImport(importText);
  }

  async getFullTypeName(type: TTypeInfo | null): Promise<string> {
    return await getFullTypeName({
      type,
      importEnum: (item) => this.importEnum(item),
      importStruct: (item) => this.importStruct(item),
      project: this.project,
    });
  }

  addVariablesToFunction(cb: CodeBuilder) {
    /*for(const exprFn of this.expressionFunctionsUsed) {
      cb.p(`let falang_global_expression_function_${exprFn} = _falangGlobal.ExpressionFunctions.${exprFn}.clone();`);
    }
    if(this.logFunctionUsed) {
      cb.p('let falang_global_logger_log = _falangGlobal.logger.log.clone();')
    }*/
  }

  printBigComment(comment: string) {
    this.codeBuilder.bigComment([comment]);
  }

  /*async importApiMethod(schemeId: string, iconId: string): Promise<void> {
    const apiItem = this.project.getApiDataById(schemeId, iconId);
    if (!apiItem) throw new Error(`Cannot find api method. schemeId: ${schemeId}, iconId: ${iconId}`);
    await this.importApiFunctionSignature(apiItem);
  }

  async importApiFunctionSignature(item: IAvailableFunctionItem): Promise<void> {

  }*/


  async generateSkewer(skewer: SkewerStore): Promise<void> {
    await super.generateSkewer(skewer);
    if(skewer.outStore) {
      if(skewer.outStore.type === 'break') {
        if(skewer.outStore.outLevel > 1) {
          this.codeBuilder.p(`_break_level = ${skewer.outStore.outLevel - 1};`);  
        }
        if(hasParentSwitchWithoutCycle({ icon: skewer.outStore, targetId: skewer.outStore.targetId })) {
          this.codeBuilder.p('_switch_break = true;');
        }
        this.codeBuilder.p('break;');
      }
      if(skewer.outStore.type === 'continue') {
        if(skewer.outStore.outLevel > 1) {
          this.codeBuilder.p(`_continue_level = ${skewer.outStore.outLevel - 1};`);
          if(hasParentSwitchWithoutCycle({ icon: skewer.outStore, targetId: skewer.outStore.targetId })) {
            this.codeBuilder.p('_switch_break = true;');
          }
          this.codeBuilder.p('break;');
        } else {
          this.codeBuilder.p('continue;');
        }
      }
      if(skewer.outStore.type === 'return') {
        const functionBlock = getParentFunctionIconBlock(skewer.outStore);
        if(functionBlock.returnStore.get().type === 'void') {
          this.codeBuilder.p('return;');
        } else {
          this.codeBuilder.p('return returnValue;');
        }
      }
    }
  }
}