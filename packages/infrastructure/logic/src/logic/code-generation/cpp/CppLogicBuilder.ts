import { IDirectory, IFile } from '@falang/frontend-core';
import { ISchemeDto } from '@falang/editor-scheme';
import { SchemeStore } from '@falang/editor-scheme';
import { LogicBuilder } from "../LogicBuilder";
import { CppLogicSchemeBuilder } from "./CppLogicSchemeBuilder";
import { cppLogicIconsBuilder } from "./cppLogicIconsBuilder";
import { runInAction } from "mobx";
import { CodeBuilder } from '@falang/editor-scheme';
import { IAvailableFunctionItem } from "../../util/loadAvailableFunctions";
import { ExpressionFunctionsNames, expressionFunctions } from "../../constants";
import { getFullTypeName } from "./getFullTypeName";
import { getInfrastructureTypeByFile } from "../util/getInfrastrucureType";
import { firstRadiationDependencies } from "mathjs";

export class CppLogicBuilder extends LogicBuilder<any> {
  async build(): Promise<void> {
    const rootDir = await this.project.frontRoot.getProjectStructure();
    await this.buildDirectory(rootDir, true);
    await this.buildGlobal();
    await this.buildCMakeLists(rootDir);
  }

  private async buildDirectory(directory: IDirectory, isRoot = false) {
    for (const file of directory.files) {
      await this.buildFile(file);
    }
    for (const dir of directory.directories) {
      await this.buildDirectory(dir);
    }
  }

  private async buildFile(file: IFile) {
    const fs = this.project.frontRoot.fs;
    const relativePath = await fs.relativePath(this.projectPath, file.path);
    const newFilePath = (await fs.resolvePath(this.outpuPath, relativePath)).replace('.falang.json', '.cpp');
    const newFileHPath = newFilePath.replace(/\.cpp$/, '.h');
    const fileDir = await fs.dirname(newFilePath);
    if (!(await fs.fileExists(fileDir))) {
      await fs.createDirectory(fileDir);
    }
    const contents = await this.project.frontRoot.loadFile(file.path);
    const doc: ISchemeDto = JSON.parse(contents);
    const infrastructure = getInfrastructureTypeByFile(file);
    if (!infrastructure) {
      console.error(`Wrong file type: ${file.type} (${file.path})`);
      return;
    }
    const scheme = new SchemeStore(
      this.project.frontRoot,
      infrastructure,
      file.type,
      this.projectPath,
      file.path,
      this.project,
    );
    const icon = scheme.createIconFromDto(doc.root, null);
    runInAction(() => {
      scheme.setRoot(icon);
      scheme.sheduleCallback.flush();
      scheme.name = doc.name
      scheme.description = doc.description;
      scheme.id = doc.id;
    });
    const schemeBuilder = new CppLogicSchemeBuilder({
      iconBuilders: cppLogicIconsBuilder,
      indexPath: this.indexPath,
      project: this.project,
      scheme,
    });
    const code = await schemeBuilder.build();
    scheme.dispose();
    await fs.saveFile(newFilePath, code);
    await fs.saveFile(newFileHPath, schemeBuilder.headResultString);
  }

  private async buildGlobal() {
    const fs = this.project.frontRoot.fs;
    const pathToFalangFile = await fs.resolvePath(this.outpuPath, 'falang_global.cpp');
    const pathToFalangHFile = await fs.resolvePath(this.outpuPath, 'falang_global.h');
    const rootPath = await this.getSchemesRootPath();

    const hb1 = new CodeBuilder();

    const imports: string[] = [];
    const b = new CodeBuilder();
    const availableApis = this.project.availableApis.slice();
    const groupedApis = new Map<string, IGroupedApis>();
    availableApis.forEach((apiData) => {
      const current = groupedApis.get(apiData.schemeId);
      if (!current) {
        groupedApis.set(apiData.schemeId, {
          schemeId: apiData.schemeId,
          schemeName: apiData.schemeName ?? '',
          apis: [apiData],
          name: apiData.name ?? '',
        });
      } else {
        current.apis.push(apiData);
      }
    });

    const apisImport: string[] = [];
    if(groupedApis.size) {
      hb1.p('struct Apis {');
      hb1.plus();
      for (const value of groupedApis.values()) {
        const relativePath = await this.fs.relativePath(rootPath, value.apis[0].path);
        const relativeFilename = relativePath.replace('.falang.json', '.h').replace(/^\.\//, '');
        apisImport.push(`#include "${relativeFilename}"`);
        const namespace = await this.getFileNamespace(value.apis[0].path);
        hb1.p(`${namespace}::${namespace}_Class ${value.schemeName};`);
      }
      hb1.minus();
      hb1.p('};');
    }

    hb1.pp(['struct FalangGlobal {']);
    hb1.indentPlus();
    if(groupedApis.size) {
      hb1.pp([
        'Apis apis;',
      ]);
    }
    hb1.indentMinus()
    hb1.pp(['};']);
    hb1.pp(['']);
    //b.closeQuote();

    const fb = new CodeBuilder();
    const hb = new CodeBuilder();

    fb.bigComment([
      'Generated by Falang',
      'Global functions',
    ], hb);

    fb.pp([
      '#include <stdlib.h>',
      '#include <string>',
      '#include <iostream>',
      ...apisImport,
    ], hb);
    fb.p('#include "falang_global.h"')
    hb.p('#ifndef _INCLUDE_FALANG_GLOBAL_');
    hb.p('#define _INCLUDE_FALANG_GLOBAL_');
    hb.pp(['namespace FalangGlobal {']);
    hb.indentPlus();
    hb.appendBuilder(hb1);
    fb.appendBuilder(b);
    hb.closeQuote();
    hb.p('#endif');
    await fs.saveFile(pathToFalangFile, fb.get());
    await fs.saveFile(pathToFalangHFile, hb.get());
  }

  private async buildCMakeLists(dir: IDirectory) {
    const outPath = this.outpuPath;
    const b = new CodeBuilder();

    const files = await this.getFilesForCmakeList(dir);
    const dirs = await this.getDirectoriesForCmakeList(dir);
    b.p('cmake_minimum_required(VERSION 2.8)');
    b.p('project(falang)');
    b.p(`add_library(falang STATIC falang_global.cpp ${files.join(' ')})`);
    if (dirs.length) {
      b.p(`include_directories(${dirs.join(' ')})`);
    }
    const filePath = await this.fs.resolvePath(outPath, 'CMakeLists.txt');
    await this.fs.saveFile(filePath, b.get());
  }

  private async getFilesForCmakeList(dir: IDirectory): Promise<string[]> {
    const returnValue: string[] = [];
    for (const file of dir.files) {
      const fileRelativePath = await this.project.getSchemeRelativePathArray(file.path);
      const pathToCpp = (await this.fs.resolvePath(this.outpuPath, ...fileRelativePath)).concat('.cpp');
      returnValue.push(pathToCpp.replace(this.outpuPath.concat('/'), ''));
    }
    for (const childDir of dir.directories) {
      returnValue.push(...await this.getFilesForCmakeList(childDir));
    }
    return returnValue;
  }

  private async getDirectoriesForCmakeList(dir: IDirectory): Promise<string[]> {
    const returnValue: string[] = [];
    for (const childDir of dir.directories) {
      const relativePath = await this.project.getSchemeRelativePathArray(dir.path);
      if (relativePath.length === 0) continue;
      const pathToDir = await this.fs.resolvePath(...relativePath);
      returnValue.push(pathToDir);
      returnValue.push(...await this.getDirectoriesForCmakeList(childDir));
    }
    return returnValue;
  }

  async getFileNamespace(path: string): Promise<string> {
    const arr = await this.project.getSchemeRelativePathArray(path);
    return `Falang_${arr.join('_')}`;
  }
}

interface IGroupedApis {
  apis: IAvailableFunctionItem[]
  schemeId: string
  schemeName: string
  name: string
}


interface FunciontDataItem {
  name: string
  parameters: string[]
  returnValue: string
}