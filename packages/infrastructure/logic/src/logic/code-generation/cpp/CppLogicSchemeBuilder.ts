import * as math from "mathjs";
import { SkewerStore } from '@falang/editor-scheme';
import { getFunctionIconConfig } from '@falang/editor-scheme';
import { CodeBuilder } from '@falang/editor-scheme';
import { TContext, TTypeInfo } from "../../constants";
import { ExpressionStore } from "../../expression/Expression.store";
import { Expression2Store } from "../../expression/Expression2.store";
import { IStructureTypeItem } from "../../ILogicProjectType";
import { IAvailableEnumItem } from "../../util/loadAvailableEnums";
import { IAvailableFunctionItem } from "../../util/loadAvailableFunctions";
import { LogicSchemeBuilder } from "../LogicSchemeBuilder";
import { getParentFunctionIconBlock } from '../util/getParentFunctionIconBlock';
import { getSwitchesLevel } from '../util/getSwicthesLevel';
import { hasParentCycle } from '../util/hasParentCycle';
import { hasParentSwitchWithoutCycle } from '../util/hasParentSwitchWithoutCycle';
import { generateExpression } from "./generateExpression";
import { getFullTypeName } from "./getFullTypeName";

export class CppLogicSchemeBuilder extends LogicSchemeBuilder {
  private readonly imports = new Set<string>();
  readonly hb = new CodeBuilder();
  public headResultString = '';
  private logVariableNameIndex = 0;
  addImport(value: string): void {
    if (this.imports.has(value)) return;
    this.imports.add(value);
  }

  getNextLogVariableIndex() {
    this.logVariableNameIndex++;
    return this.logVariableNameIndex;
  }

  async generateExpression(expression: Expression2Store, resultType: TTypeInfo, context?: TContext): Promise<string> {
    const node = expression.mathNode;
    if (!node) throw new Error('Node is null');
    return await this.generateExpressionFromMathNode(node, resultType, context);
  }

  async expr(node: math.MathNode | null, resultType: TTypeInfo, context: TContext): Promise<string> {
    if(!node) {
      throw new Error('Math node is null');
    }
    return this.generateExpressionFromMathNode(node, resultType, context);
  }

  private async generateExpressionFromMathNode(node: math.MathNode, resultType: TTypeInfo, context?: TContext): Promise<string> {
    return await generateExpression({
      node,
      resultType,
      schemeBuilder: this,
      context,
    });
  }

  async build(): Promise<string> {
    if(this.scheme.loaded) {
      await this.generateIcon(this.scheme.root);
    }    
    const b = new CodeBuilder();
    const hb = new CodeBuilder();
    const relativePathArray = await this.project.getSchemeRelativePathArray(this.path);
    const namespaceName = `Falang_${relativePathArray.join('_')}`;
    const includeConstant = `_INCLUDE_SRC_${namespaceName.toUpperCase()}_`;
    b.bigComment([
      'Generated by Falang',
      `Document: ${this.scheme.name}`,
      `Id: ${this.scheme.id}`
    ],hb);
    hb.p(
      `#ifndef ${includeConstant}`,
      `#define ${includeConstant}`,
    );
    this.imports.forEach((i) => {
      b.pp([i], hb);
    });
    b.pp([
      '#include <string>',
      '#include <vector>',
    ], hb);
    b.pp([`namespace ${namespaceName} {`], hb);
    b.indentPlus(hb);
    b.appendBuilder(this.codeBuilder);
    hb.appendBuilder(this.hb);
    b.indentMinus(hb);
    b.pp(['};'], hb);
    hb.p('#endif');
    this.headResultString = hb.get();
    return b.get();
  }

  /**
   * @deprecated
   * @param expression 
   * @param resultType 
   * @returns 
   */
  async generateExpressionOld(expression: ExpressionStore, resultType: TTypeInfo, context?: TContext): Promise<string> {
    const node = expression.mathNode;
    if (!node) throw new Error('Node is null');
    return await this.generateExpressionFromMathNode(node, resultType, context);
  }
  async generateEmptyValue(type: TTypeInfo): Promise<string> {
    switch (type.type) {
      case 'number':
        return '0';
      case 'string':
        return '\'\'';
      case 'boolean':
        return 'false';
      case 'array':
        this.addImport("#include <vector>");
        return `${await this.getFullTypeName(type)}{}`;
      default:
        throw new Error(`Wrong type for generateEmptyValue: ${type.type}`);
    }
  }

  async importFunction(item: IAvailableFunctionItem) {
    const relativePath = await this.fs.relativePath(await this.fs.dirname(this.path), item.path);
    const relativeFilename = relativePath.replace('.falang.json', '.h').replace(/^\.\//, '');
    const importText = `#include "${relativeFilename}"`;
    this.addImport(importText);
  }

  async importStruct(item: IStructureTypeItem) {
    const relativePath = await this.fs.relativePath(await this.fs.dirname(this.path), item.path);
    const relativeFilename = relativePath.replace('.falang.json', '.h').replace(/^\.\//, '');
    const importText = `#include "${relativeFilename}"`;
    this.addImport(importText);
  }

  async importEnum(item: IAvailableEnumItem) {
    const relativePath = await this.fs.relativePath(await this.fs.dirname(this.path), item.path);
    const relativeFilename = relativePath.replace('.falang.json', '.h').replace(/^\.\//, '');
    const importText = `#include "${relativeFilename}"`;
    this.addImport(importText);
  }

  async importGlobal() {
    const rootPath = await this.getSchemesRootPath();
    const pathToFalangFile = await this.fs.resolvePath(rootPath, 'falang_global.h');
    const relativePathToGlob = await this.fs.relativePath(await this.fs.dirname(this.path), pathToFalangFile);
    const importText = `#include "${relativePathToGlob.replace(/^\.\//, '')}"`;
    this.addImport(importText);
  }

  async getFullTypeName(type: TTypeInfo | null): Promise<string> {
    return await getFullTypeName({
      type,
      importEnum: (item) => this.importEnum(item),
      importStruct: (item) => this.importStruct(item),
      project: this.project,
    });
  }

  /*addVariablesToFunction(cb: CodeBuilder) {
    for(const exprFn of this.expressionFunctionsUsed) {
      cb.p(`let falang_global_expression_function_${exprFn} = _falangGlobal.ExpressionFunctions.${exprFn}.clone();`);
    }
    if(this.logFunctionUsed) {
      cb.p('let falang_global_logger_log = _falangGlobal.logger.log.clone();')
    }
  }*/

  printBigComment(comment: string, b2?: CodeBuilder) {
    this.codeBuilder.bigComment([comment], b2);
  }

  async getFileNamespace(path: string): Promise<string> {
    const arr = await this.project.getSchemeRelativePathArray(path);
    return `Falang_${arr.join('_')}`;
  }

  /*async importApiMethod(schemeId: string, iconId: string): Promise<void> {
    const apiItem = this.project.getApiDataById(schemeId, iconId);
    if (!apiItem) throw new Error(`Cannot find api method. schemeId: ${schemeId}, iconId: ${iconId}`);
    await this.importApiFunctionSignature(apiItem);
  }

  async importApiFunctionSignature(item: IAvailableFunctionItem): Promise<void> {

  }*/

  async generateSkewer(skewer: SkewerStore): Promise<void> {
    await super.generateSkewer(skewer);
    if(skewer.outStore) {
      if(skewer.outStore.type === 'break') {
        if(skewer.outStore.outLevel > 1) {
          this.codeBuilder.p(`_break_level = ${skewer.outStore.outLevel - 1};`);  
        }
        if(hasParentSwitchWithoutCycle({ icon: skewer.outStore, targetId: skewer.outStore.targetId })) {
          this.codeBuilder.p('_switch_break = true;');
        }
        this.codeBuilder.p('break;');
      }
      if(skewer.outStore.type === 'continue') {
        if(skewer.outStore.outLevel > 1) {
          this.codeBuilder.p(`_continue_level = ${skewer.outStore.outLevel - 1};`);
          if(hasParentSwitchWithoutCycle({ icon: skewer.outStore, targetId: skewer.outStore.targetId })) {
            this.codeBuilder.p('_switch_break = true;');
          }
          this.codeBuilder.p('break;');
        } else {
          this.codeBuilder.p('continue;');
        }
      }
      if(skewer.outStore.type === 'return') {
        const functionBlock = getParentFunctionIconBlock(skewer.outStore);
        if(functionBlock.returnStore.get().type === 'void') {
          this.codeBuilder.p('return;');
        } else {
          this.codeBuilder.p('return returnValue;');
        }
      }
    }
  }


}