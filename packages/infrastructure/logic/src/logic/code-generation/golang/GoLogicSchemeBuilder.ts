import * as math from "mathjs";
import { SkewerStore } from '@falang/editor-scheme';
import { FunctionIconStore } from '@falang/editor-scheme';
import { CodeBuilder } from '@falang/editor-scheme';
import { FunctionHeaderBlockStore } from '../../blocks/function-header/FunctionHeader.block.store';
import { TContext, TTypeInfo } from "../../constants";
import { ExpressionStore } from "../../expression/Expression.store";
import { Expression2Store } from "../../expression/Expression2.store";
import { IStructureTypeItem } from "../../ILogicProjectType";
import { IAvailableEnumItem } from "../../util/loadAvailableEnums";
import { IAvailableFunctionItem } from "../../util/loadAvailableFunctions";
import { ucfirst } from '../../util/ucfirst';
import { LogicSchemeBuilder } from "../LogicSchemeBuilder";
import { getParentFunctionIconBlock } from '../util/getParentFunctionIconBlock';
import { hasParentSwitchWithoutCycle } from '../util/hasParentSwitchWithoutCycle';
import { castToNumber } from "./convertSymbol";
import { generateExpression } from "./generateExpression";
import { getFullTypeName } from "./getFullTypeName";

export class GoLogicSchemeBuilder extends LogicSchemeBuilder {
  private readonly imports = new Set<string>();
  private readonly functionParametersUsed = new Set<string>();
  private readonly expressionFunctionsUsed = new Set<string>();
  private logFunctionUsed = false;

  addImport(value: string): void {
    if (this.imports.has(value)) return;
    this.imports.add(value);
  }

  useFunctionParameter(parameter: string) {
    this.functionParametersUsed.add(parameter);
  }

  useExpressionFunction(functionName: string): void {
    this.addGlobalVariableToFunction();
    this.expressionFunctionsUsed.add(functionName);
  }

  useLogFunction(): void {
    this.logFunctionUsed = true;
  }

  async generateExpression(expression: Expression2Store, resultType: TTypeInfo, context?: TContext): Promise<string> {
    const node = expression.mathNode;
    if (!node) throw new Error('Node is null');
    return await this.generateExpressionFromMathNode(node, resultType, context);
  }

  async expr(node: math.MathNode | null, resultType: TTypeInfo, context: TContext): Promise<string> {
    if(!node) {
      throw new Error('Math node is null');
    }
    return this.generateExpressionFromMathNode(node, resultType, context);
  }

  private async generateExpressionFromMathNode(node: math.MathNode, resultType: TTypeInfo, context?: TContext): Promise<string> {
    return await generateExpression({
      node,
      resultType,
      schemeBuilder: this,
      context,
    });
  }

  async getPackageName() {    
    return this.scheme.name;
  }

  async build(): Promise<string> {
    if(this.scheme.loaded) {
      await this.generateIcon(this.scheme.root);
    }    
    const b = new CodeBuilder();
    b.bigComment([
      'Generated by Falang',
      `Document: ${this.scheme.name}`,
      `Id: ${this.scheme.id}`
    ]);
    const packageName = await this.getPackageName();
    b.p(`package ${packageName === 'main' ? 'main1' : packageName}`);
    b.p('');
    b.p
    if(this.imports.size) {
      b.p(`import (`);
      b.indentPlus()
      this.imports.forEach((i) => {
        b.p(`"${i}"`);
      });
      b.minus();
      b.p(')');
    }
    for(const p of this.functionParametersUsed) {

    }

    b.appendBuilder(this.codeBuilder);
    return b.get();
  }

  /**
   * @deprecated
   * @param expression 
   * @param resultType 
   * @returns 
   */
  async generateExpressionOld(expression: ExpressionStore, resultType: TTypeInfo, context?: TContext): Promise<string> {
    const node = expression.mathNode;
    if (!node) throw new Error('Node is null');
    return await this.generateExpressionFromMathNode(node, resultType, context);
  }
  async generateEmptyValue(type: TTypeInfo): Promise<string> {
    switch (type.type) {
      case 'number':
        return castToNumber(type, '0');
      case 'string':
        return '\'\'';
      case 'boolean':
        return 'false';
      case 'struct':
        return `${await this.getFullTypeName(type)}{}`;
      case 'array':
        const elementType = await this.getFullTypeName(type.elementType);
        return `[]${elementType}{}`;
      default:
        throw new Error(`Wrong type for generateEmptyValue: ${type.type}`);
    }
  }

  async importFunction(item: IAvailableFunctionItem) {
    await this.importCommon(item);
  }

  async importStruct(item: IStructureTypeItem) {
    return await this.importCommon(item);
  }

  async importEnum(item: IAvailableEnumItem) {
    await this.importCommon(item);
  }

  private async importCommon(item: IAvailableFunctionItem | IStructureTypeItem | IAvailableEnumItem): Promise<boolean> {
    const relativePath = await this.fs.relativePath(await this.getSchemesRootPath(), item.path);
    const thisPath = await this.fs.relativePath(await this.getSchemesRootPath(), this.path);
    if(relativePath === thisPath) return false;
    const pathArray = relativePath.replace('.falang.json', '').split(/[\/\\]/).filter(item => item !== '.');
    if(pathArray.length === 0) return false;
    const importText = pathArray.join('/');
    this.addImport(`application/falang/${importText}`);
    return true;
  }

  async importGlobal() {
    // const thisPath = await this.fs.relativePath(await this.getSchemesRootPath(), this.path);
    const packageName = await this.getPackageName();
    if(packageName === 'falang') {
      return;
    }
    this.addImport("application/falang/falang_global");
  }

  async getFullTypeName(type: TTypeInfo | null): Promise<string> {
    return await getFullTypeName({
      type,
      importEnum: (item) => this.importEnum(item),
      importStruct: (item) => this.importStruct(item),
      project: this.project,
    });
  }


  addVariablesToFunction(b: CodeBuilder) {
    if(this.functionParametersUsed.has('FalangGlobal')) {
      b.p('var FalangGlobal = params.FalangGlobal;');
    }
    this.functionParametersUsed.forEach((p) => {
      if(p === 'FalangGlobal') return;
      b.p(`var ${p} = params.${ucfirst(p)};`);
    });
  }

  addVariableToFunction(variableName: string) {
    this.functionParametersUsed.add(variableName);
  }

  addVariableToFunctionIfInContext(variableName: string) {
    const functionIcon = this.scheme.root.block as FunctionHeaderBlockStore;
    const context = functionIcon.scopeVariables;
    const varName = variableName.replace(/\.(.*)$/, '');
    if(false === (varName in context)) return;
    this.addVariableToFunction(varName);
  }

  addGlobalVariableToFunction() {
    this.functionParametersUsed.add('FalangGlobal');
  }

  printBigComment(comment: string) {
    this.codeBuilder.bigComment([comment]);
  }

  async generateSkewer(skewer: SkewerStore): Promise<void> {
    await super.generateSkewer(skewer);
    if(skewer.outStore) {
      if(skewer.outStore.type === 'break') {
        if(skewer.outStore.outLevel > 1) {
          this.codeBuilder.p(`_break_level = ${skewer.outStore.outLevel - 1};`);  
        }
        if(hasParentSwitchWithoutCycle({ icon: skewer.outStore, targetId: skewer.outStore.targetId })) {
          this.codeBuilder.p('_switch_break = true;');
        }
        this.codeBuilder.p('break;');
      }
      if(skewer.outStore.type === 'continue') {
        if(skewer.outStore.outLevel > 1) {
          this.codeBuilder.p(`_continue_level = ${skewer.outStore.outLevel - 1};`);
          if(hasParentSwitchWithoutCycle({ icon: skewer.outStore, targetId: skewer.outStore.targetId })) {
            this.codeBuilder.p('_switch_break = true;');
          }
          this.codeBuilder.p('break;');
        } else {
          this.codeBuilder.p('continue;');
        }
      }
      if(skewer.outStore.type === 'return') {
        const functionBlock = getParentFunctionIconBlock(skewer.outStore);
        if(functionBlock.returnStore.get().type === 'void') {
          this.codeBuilder.p('return;');
        } else {
          this.codeBuilder.p('return returnValue;');
        }
      }
    }
  }

  /*async importApiMethod(schemeId: string, iconId: string): Promise<void> {
    const apiItem = this.project.getApiDataById(schemeId, iconId);
    if (!apiItem) throw new Error(`Cannot find api method. schemeId: ${schemeId}, iconId: ${iconId}`);
    await this.importApiFunctionSignature(apiItem);
  }

  async importApiFunctionSignature(item: IAvailableFunctionItem): Promise<void> {

  }*/


}