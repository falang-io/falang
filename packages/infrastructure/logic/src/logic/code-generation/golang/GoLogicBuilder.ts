import { IDirectory, IFile } from '@falang/frontend-core';
import { ISchemeDto } from '@falang/editor-scheme';
import { SchemeStore } from '@falang/editor-scheme';
import { LogicBuilder } from "../LogicBuilder";
import { GoLogicSchemeBuilder } from "./GoLogicSchemeBuilder";
import { goLogicIconsBuilder } from "./goLogicIconsBuilder";
import { runInAction } from "mobx";
import { CodeBuilder } from '@falang/editor-scheme';
import { IAvailableFunctionItem } from "../../util/loadAvailableFunctions";
import { getInfrastructureTypeByFile } from "../util/getInfrastrucureType";
import { ucfirst } from '../../util/ucfirst';

export class GoLogicBuilder extends LogicBuilder<any> {
  async build(): Promise<void> {
    const rootDir = await this.project.frontRoot.getProjectStructure();
    await this.buildDirectory(rootDir, true);
    await this.buildGlobal();
  }

  private async buildDirectory(directory: IDirectory, isRoot = false) {
    for(const file of directory.files) {
      await this.buildFile(file);
    }
    for(const dir of directory.directories) {
      await this.buildDirectory(dir);
    }
  }

  private async buildFile(file: IFile) {
    const fs = this.project.frontRoot.fs;    
    const relativePath = await fs.relativePath(this.projectPath, file.path);
    let baseName = (await fs.basename(file.path)).replace('.falang.json', '');
    if(baseName === 'main') baseName = 'main1';
    const newFilePath = (await fs.resolvePath(this.outpuPath, relativePath.replace('.falang.json', '').replace(/\/main$/, '/main1'), `${baseName}.go`));
    //console.log('asd', relativePath.replace('.falang.json', ''), newFilePath);
    const fileDir = await fs.dirname(newFilePath);
    if(!(await fs.fileExists(fileDir))) {
      await fs.createDirectory(fileDir);
    }
    const contents = await this.project.frontRoot.loadFile(file.path);
    const doc: ISchemeDto = JSON.parse(contents);
    const infrastructure = getInfrastructureTypeByFile(file);
    if(!infrastructure) {
      console.error(`Wrong file type: ${file.type} (${file.path})`);
      return;
    }
    const scheme = new SchemeStore(
      this.project.frontRoot,
      infrastructure,
      file.type,
      this.projectPath,
      file.path,
      this.project,
    );
    const icon = scheme.createIconFromDto(doc.root, null);
    runInAction(() => {
      scheme.setRoot(icon);
      scheme.sheduleCallback.flush();
      scheme.name = doc.name
      scheme.description = doc.description;
      scheme.id = doc.id;
    });
    const schemeBuilder = new GoLogicSchemeBuilder({
      iconBuilders: goLogicIconsBuilder,
      indexPath: this.indexPath,
      project: this.project,
      scheme,
    });
    const code = await schemeBuilder.build();
    scheme.dispose();
    await fs.saveFile(newFilePath, code);
  }

  private async buildGlobal() {
    const fs = this.project.frontRoot.fs;
    const pathToFalangFile = await fs.resolvePath(this.outpuPath, 'falang_global/falang_global.go');
    const rootPath = await this.getSchemesRootPath();

    const imports: string[] = [];
    const b = new CodeBuilder();
    const availableApis = this.project.availableApis.slice();
    const groupedApis = new Map<string, IGroupedApis>();
    availableApis.forEach((apiData) => {
      const current = groupedApis.get(apiData.schemeId);
      if(!current) {
        groupedApis.set(apiData.schemeId, {
          schemeId: apiData.schemeId,
          schemeName: apiData.schemeName ?? '',
          apis: [apiData],
          name: apiData.name ?? '',
        });
      } else {
        current.apis.push(apiData);
      }
    });
    if(groupedApis.size) {
      b.p(`type Apis struct {`);
      b.plus();
      for(const value of groupedApis.values()) {
        const apiFilePath = value.apis[0].path;
        const relativePathToApi = await fs.relativePath(rootPath, apiFilePath.replace('.falang.json', ''));
        const pathArray = relativePathToApi.replace('.falang.json', '').split(/[\/\\]/).filter(item => item !== '.');
        if(pathArray.length === 0) return false;
        const importText = pathArray.join('/');
        imports.push(`application/falang/${importText}`);
        b.p(`${ucfirst(value.schemeName)} ${value.schemeName}.${value.schemeName}`);
      }
      b.closeQuote();
    }

    b.p('type FalangGlobal struct {');
    b.indentPlus();
    if(groupedApis.size) {
      b.p('Apis                Apis');
    }
    b.closeQuote();

    const fb = new CodeBuilder();
    fb.bigComment([
      'Generated by Falang',
      'Global functions',
    ]);
    fb.p(
      'package falang_global',
    );
    if(imports.length) {
      fb.p(
        'import (',
        ...imports.map((i) => `  "${i}"`),
        ')',
      ) 
    }
    fb.appendBuilder(b);
    /**
     * IExpressionFunctions builder
     */
    const eb = new CodeBuilder();
    fb.appendBuilder(eb);
    await fs.saveFile(pathToFalangFile, fb.get());
  }
}

interface IGroupedApis {
  apis: IAvailableFunctionItem[]
  schemeId: string
  schemeName: string
  name: string
}


interface FunciontDataItem {
  name: string
  parameters: string[]
  returnValue: string
}