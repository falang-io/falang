import * as math from "mathjs";
import { SkewerStore } from '@falang/editor-scheme';
import { CodeBuilder } from '@falang/editor-scheme';
import { TContext, TTypeInfo } from "../../constants";
import { ExpressionStore } from "../../expression/Expression.store";
import { Expression2Store } from "../../expression/Expression2.store";
import { IStructureTypeItem } from "../../ILogicProjectType";
import { IAvailableEnumItem } from "../../util/loadAvailableEnums";
import { IAvailableFunctionItem } from "../../util/loadAvailableFunctions";
import { LogicSchemeBuilder } from "../LogicSchemeBuilder";
import { getParentFunctionIconBlock } from '../util/getParentFunctionIconBlock';
import { hasParentSwitchWithoutCycle } from '../util/hasParentSwitchWithoutCycle';
import { generateExpression } from "./generateExpression";
import { getFullTypeName } from "./getFullTypeName";

export class TypescriptLogicSchemeBuilder extends LogicSchemeBuilder {
  private readonly imports = new Set<string>();

  addImport(value: string) {
    if (this.imports.has(value)) return;
    this.imports.add(value);
  }

  async generateExpression(expression: Expression2Store, resultType: TTypeInfo, context: TContext): Promise<string> {
    const node = expression.mathNode;
    if (!node) throw new Error('Node is null');
    return await this.generateExpressionFromMathNode(node, resultType, context);
  }

  async expr(node: math.MathNode | null, resultType: TTypeInfo, context: TContext): Promise<string> {
    if(!node) {
      throw new Error('Math node is null');
    }
    return this.generateExpressionFromMathNode(node, resultType, context);
  }

  private async generateExpressionFromMathNode(node: math.MathNode, resultType: TTypeInfo, context: TContext): Promise<string> {
    return await generateExpression({
      node,
      resultType,
      schemeBuilder: this,
      context,
    });
  }

  async build(): Promise<string> {
    if(this.scheme.loaded) {
      await this.generateIcon(this.scheme.root);
    }    
    const b = new CodeBuilder();
    b.bigComment([
      'Generated by Falang',
      `Document: ${this.scheme.name}`,
      `Id: ${this.scheme.id}`
    ]);
    this.imports.forEach((i) => {
      b.p(i);
    })
    b.appendBuilder(this.codeBuilder);
    return b.get();
  }

  /**
   * @deprecated
   * @param expression 
   * @param resultType 
   * @returns 
   */
  async generateExpressionOld(expression: ExpressionStore, resultType: TTypeInfo, context: TContext): Promise<string> {
    const node = expression.mathNode;
    if (!node) throw new Error('Node is null');
    return await this.generateExpressionFromMathNode(node, resultType, context);
  }
  async generateEmptyValue(type: TTypeInfo): Promise<string> {
    switch (type.type) {
      case 'number':
        return '0';
      case 'string':
        return '\'\'';
      case 'boolean':
        return 'false';
      case 'struct': {
        const returnArr: string[] = [];
        const structType = this.project.getStructByType(type);
        if(!structType) return '';
        for(const propertyName in structType.properties) {
          returnArr.push(`${propertyName}:${await this.generateEmptyValue(structType.properties[propertyName])}`)
        }
        return `{${returnArr.join(',')}}`;
      }
      case 'array': return '[]';
      default:
        throw new Error(`Wrong type for generateEmptyValue: ${type.type}`);
    }
  }

  async importFunction(item: IAvailableFunctionItem) {
    const relativePath = await this.fs.relativePath(await this.fs.dirname(this.path), item.path);
    const relativeFilename = relativePath.replace('.falang.json', '');
    const importText = `import { ${item.name} } from '${relativeFilename}';`;
    this.addImport(importText);
  }

  async importStruct(item: IStructureTypeItem) {
    if(item.path === this.path) return;
    const relativePath = await this.fs.relativePath(await this.fs.dirname(this.path), item.path);
    const relativeFilename = relativePath.replace('.falang.json', '');
    const importText = `import { ${item.name} } from '${relativeFilename}';`;
    this.addImport(importText);
  }

  async importEnum(item: IAvailableEnumItem) {
    const relativePath = await this.fs.relativePath(await this.fs.dirname(this.path), item.path);
    const relativeFilename = relativePath.replace('.falang.json', '');
    const importText = `import { ${item.name} } from '${relativeFilename}';`;
    this.addImport(importText);
  }

  async importGlobal() {
    const rootPath = await this.getSchemesRootPath();
    const pathToFalangFile = await this.fs.resolvePath(rootPath, '_falang');
    const relativePathToGlob = await this.fs.relativePath(await this.fs.dirname(this.path), pathToFalangFile);
    const importText = `import { FalangGlobal } from '${relativePathToGlob}';`;
    this.addImport(importText);
  }

  async getFullTypeName(type: TTypeInfo | null): Promise<string> {
    return await getFullTypeName({
      type,
      importEnum: (item) => this.importEnum(item),
      importStruct: (item) => this.importStruct(item),
      project: this.project,
    });
  }

  printBigComment(comment: string) {
    this.codeBuilder.bigComment([comment]);
  }

  async generateSkewer(skewer: SkewerStore): Promise<void> {
    await super.generateSkewer(skewer);
    if(skewer.outStore) {
      if(skewer.outStore.type === 'break') {
        if(skewer.outStore.outLevel > 1) {
          this.codeBuilder.p(`_break_level = ${skewer.outStore.outLevel - 1};`);  
        }
        if(hasParentSwitchWithoutCycle({ icon: skewer.outStore, targetId: skewer.outStore.targetId })) {
          this.codeBuilder.p('_switch_break = true;');
        }
        this.codeBuilder.p('break;');
      }
      if(skewer.outStore.type === 'continue') {
        if(skewer.outStore.outLevel > 1) {
          this.codeBuilder.p(`_continue_level = ${skewer.outStore.outLevel - 1};`);
          if(hasParentSwitchWithoutCycle({ icon: skewer.outStore, targetId: skewer.outStore.targetId })) {
            this.codeBuilder.p('_switch_break = true;');
          }
          this.codeBuilder.p('break;');
        } else {
          this.codeBuilder.p('continue;');
        }
      }
      if(skewer.outStore.type === 'return') {
        const functionBlock = getParentFunctionIconBlock(skewer.outStore);
        if(functionBlock.returnStore.get().type === 'void') {
          this.codeBuilder.p('return;');
        } else {
          this.codeBuilder.p('return returnValue;');
        }
      }
    }
  }

  /*async importApiMethod(schemeId: string, iconId: string): Promise<void> {
    const apiItem = this.project.getApiDataById(schemeId, iconId);
    if (!apiItem) throw new Error(`Cannot find api method. schemeId: ${schemeId}, iconId: ${iconId}`);
    await this.importApiFunctionSignature(apiItem);
  }

  async importApiFunctionSignature(item: IAvailableFunctionItem): Promise<void> {

  }*/


}